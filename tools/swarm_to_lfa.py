#!/usr/bin/env python

# Author: Jannis Teunissen

# Description: Convert output of particle swarm to 2D transport data tables that
# can be used in to simulate streamers in magnetic fields

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import argparse
import numpy as np
import sys


def get_args():
    # Get and parse the command line arguments
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='''Convert particle swarm data to tables that can be used in discharge
        simulations with the local field approximation. Author: Jannis
        Teunissen, jannis@teunissen.net''',
        epilog='''Usage example: ./swarm_to_lfa.py table.txt AIR > lfa_data.txt''')
    parser.add_argument('in_file', type=argparse.FileType('r'),
                        help='File with output from swarm_cli')
    parser.add_argument('gas_name', type=str,
                        help='Gas mixture name (e.g., AIR)')
    parser.add_argument('-magnetic', action='store_true',
                        help='Use local field approximation with B-field')
    return parser.parse_args()


def write_col(varname, name, multicol=False):
    ix_col = colnames.index(varname)

    print("E[V/m]_" + name)
    print(args.gas_name)
    if multicol:
        print("NUM_COLUMNS: ", n_angles)
        print("COL_VALUES: ", ' '.join(map(str, angles)))
    print("COMMENT: generated by particle_swarm")
    print("-----------------------")
    for i in range(n_fields):
        if multicol:
            ix = i*n_angles
            fld = td[ix, ix_E]
            vals = ["{:.4E}".format(val) for val in td[ix:ix+n_angles, ix_col]]
            print("{:.4E} {}".format(fld, ' '.join(vals)))
        else:
            fld = (td[i, ix_Ey]**2 + td[i, ix_Ez]**2)**0.5
            val = "{:.4E}".format(td[i, ix_col])
            print("{:.4E} {}".format(fld, val))
    print("-----------------------")
    print("")


if __name__ == '__main__':
    args = get_args()

    # Read header
    while True:
        hdr = args.in_file.readline()
        if hdr.startswith('# Column names:'):
            hdr = args.in_file.readline()
            # Strip comment and newline
            hdr = hdr[2:].strip()
            colnames = hdr.split(' ')
            break

    # Read data
    td = np.loadtxt(args.in_file)

    ix_E = colnames.index('E')
    ix_angle = colnames.index('angle')
    angles = np.unique(td[:, ix_angle])
    n_fields = td.shape[0] // len(angles)
    n_angles = len(angles)

    # There should only be one magnetic field
    ix_B = colnames.index('B')

    if not args.magnetic:
        if not np.allclose(td[:, ix_B], 0.0):
            sys.exit("Error: non-zero B-field present (try -magnetic)")
        if not np.allclose(td[:, ix_angle], 0.0):
            sys.exit("Error: non-zero angle between E,B was used (try -magnetic)")
        if n_angles > 1:
            sys.exit("Error: multiple angles used (try -magnetic)")
    elif not np.allclose(td[:, ix_B], td[0, ix_B]):
            sys.exit("Error: more than one B-field present. "
                     "This script works for varying angles.")

    if args.magnetic:
        write_col('mu_B', 'muB[m2/Vs]', multicol=True)
        write_col('mu_xB', 'muxB[m2/Vs]', multicol=True)
        write_col('mu_ExB', 'muExB[m2/Vs]', multicol=True)
        write_col('alpha', 'alpha[1/m]', multicol=True)
        write_col('eta', 'eta[1/m]', multicol=True)
        # Take the diffusion coefficient perpendicular to E and B
        write_col('diff_1', 'diff_xB[m2/s]', multicol=True)
        write_col('diff_3', 'diff_B[m2/s]', multicol=True)
        write_col('energy', 'energy[eV]', multicol=True)
    else:
        write_col('mu_B', 'mu[m2/Vs]')
        write_col('alpha', 'alpha[1/m]')
        write_col('eta', 'eta[1/m]')
        write_col('diff_3', 'diffL[m2/s]')
        write_col('diff_1', 'diffT[m2/s]')
        write_col('energy', 'energy[eV]')
